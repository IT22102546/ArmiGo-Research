generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // PERFORMANCE: Connection pooling is handled via DATABASE_URL parameters
  // Example: ?connection_limit=10&pool_timeout=20
  // For production, consider using PgBouncer or Prisma Data Proxy
}

model Subject {
  id                  String                     @id @default(cuid())
  name                String                     @unique
  code                String?                    @unique
  description         String?
  category            String?
  imageUrl            String?
  isActive            Boolean                    @default(true)
  deletedAt           DateTime?
  deletedBy           String?
  createdAt           DateTime                   @default(now())
  updatedAt           DateTime                   @updatedAt
  classes             Class[]                    @relation("ClassSubject")
  courseMaterials     CourseMaterial[]           @relation("CourseMaterialSubject")
  exams               Exam[]                     @relation("ExamSubject")
  teacherAssignments  TeacherSubjectAssignment[] @relation("SubjectAssignments")
  timetables          Timetable[]                @relation("TimetableSubject")
  transferRequests    TransferRequest[]          @relation("TransferRequestSubject")
  publicationSubjects PublicationSubject[]       @relation("PublicationSubjects")
  gradeSubjects       GradeSubject[]
  subjectMediums      SubjectMedium[]
  studentSubjects     StudentSubject[]
  chapters            SubjectChapter[]           @relation("SubjectChapters")

  @@index([deletedAt])
  @@index([isActive])
  @@map("subjects")
}

model User {
  id                     String     @id @default(cuid())
  phone                  String     @unique
  email                  String?    @unique
  password               String
  firstName              String
  lastName               String
  role                   UserRole
  status                 UserStatus @default(ACTIVE)
  avatar                 String?
  dateOfBirth            DateTime?
  bio                    String?
  address                String?
  city                   String?
  districtId             String?
  zoneId                 String?
  postalCode             String?
  phoneVerified          Boolean    @default(false)
  emailVerified          Boolean    @default(false)
  lastLoginAt            DateTime?
  lastLogoutAt           DateTime?
  passwordResetToken     String?
  passwordResetExpiresAt DateTime?
  username               String?    @unique

  twoFactorEnabled     Boolean          @default(false)
  twoFactorSecret      String?
  twoFactorBackupCodes String[]
  twoFactorMethod      TwoFactorMethod?
  passwordHistory      String[]
  passwordChangedAt    DateTime?
  deletedAt            DateTime?
  deletedBy            String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  accountLockout       AccountLockout?  @relation("UserAccountLockout")
  // Core user data and relationships
  district             District?        @relation("UserDistrict", fields: [districtId], references: [id])
  zone                 Zone?            @relation("UserZone", fields: [zoneId], references: [id])
  studentProfile       StudentProfile?
  teacherProfile       TeacherProfile?

  // Primary user-owned entities
  createdClasses Class[]        @relation("CreatedClasses")
  enrollments    Enrollment[]
  examAttempts   ExamAttempt[]
  examRankings   ExamRanking[]
  createdExams   Exam[]         @relation("ExamCreator")
  payments       Payment[]
  wallet         Wallet?        @relation("UserWallet")
  invoices       Invoice[]      @relation("StudentInvoices")
  notifications  Notification[]

  // Course and learning activities
  attendanceRecords     Attendance[]         @relation("AttendanceUser")
  sessionParticipations SessionParticipant[]
  studentProgress       StudentProgress?     @relation("StudentProgressRecord")
  timetableEntries      Timetable[]          @relation("TimetableTeacher")
  hostedSessions        VideoSession[]       @relation("SessionHost")

  // Communication
  sentChatMessages     ChatMessage[]  @relation("MessagesSent")
  receivedChatMessages ChatMessage[]  @relation("MessagesReceived")
  createdAnnouncements Announcement[] @relation("AnnouncementsCreated")

  // Publications and resources
  publicationPurchases PublicationPurchase[] @relation("PublicationPurchases")
  publicationReviews   PublicationReview[]   @relation("PublicationReviews")
  createdPublications  Publication[]         @relation("PublicationCreator")
  uploadedMaterials    CourseMaterial[]      @relation("MaterialsUploaded")

  // Authentication and security
  authSessions    AuthSession[]    @relation("UserSessions")
  refreshTokens   RefreshToken[]
  deviceTokens    DeviceToken[]    @relation("UserDeviceTokens")
  faceRecognition FaceRecognition? @relation("UserFaceRecognition")

  // Access management and approvals
  temporaryAccess     TemporaryAccess[]    @relation("TemporaryAccessUser")
  grantedAccess       TemporaryAccess[]    @relation("AccessGrantor")
  revokedAccess       TemporaryAccess[]    @relation("AccessRevoker")
  transferRequests    TransferRequest[]    @relation("TransferRequester")
  verifiedTransfers   TransferRequest[]    @relation("TransferVerifier")
  transferAcceptances TransferAcceptance[] @relation("TransferAcceptor")
  sentMessages        TransferMessage[]    @relation("TransferMessageSender")

  // Exam and grading workflows
  correctedExamAttempts ExamAttempt[] @relation("ExamCorrectors")
  unlockedExamAttempts  ExamAttempt[] @relation("ExamAttemptUnlockers")
  approvedExams         Exam[]        @relation("ExamApprover")
  deletedExams          Exam[]        @relation("ExamDeleters")

  // Class and scheduling management
  deletedClasses         Class[]               @relation("ClassDeleters")
  teacherLeaves          TeacherAvailability[] @relation("TeacherLeaves")
  replacementAssignments TeacherAvailability[] @relation("ReplacementTeacher")
  leaveRequests          TeacherAvailability[] @relation("LeaveRequester")
  approvedLeaves         TeacherAvailability[] @relation("LeaveApprover")
  rejectedLeaves         TeacherAvailability[] @relation("LeaveRejector")
  teacherRescheduling    ClassRescheduling[]   @relation("TeacherRescheduling")
  reschedulingRequests   ClassRescheduling[]   @relation("ReschedulingRequests")
  approvedReschedulings  ClassRescheduling[]   @relation("ApprovedReschedulings")
  rejectedReschedulings  ClassRescheduling[]   @relation("RejectedReschedulings")
  timetableChanges       TimetableChange[]     @relation("ChangeCreator")
  newTeacherChanges      TimetableChange[]     @relation("newTeacherId")

  // Enrollment and payments
  deletedEnrollments    Enrollment[]            @relation("EnrollmentDeleters")
  reconciliationMatches PaymentReconciliation[] @relation("ReconciliationMatchers")

  // Student progress and promotions
  deletedProgress StudentProgress[] @relation("StudentProgressDeleters")

  // Administrative creation/audit (selected essential ones)
  createdInvoices      Invoice[]      @relation("InvoiceCreators")
  createdSeminars      Seminar[]      @relation("SeminarsCreated")
  createdVideoSessions VideoSession[] @relation("VideoSessionCreator")
  createdExamTemplates ExamTemplate[] @relation("ExamTemplateCreator")
  feedbacks            Feedback[]     @relation("FeedbacksGiven")
  approvedMessages     ChatMessage[]  @relation("MessagesApproved")

  // Security and audit logs (essential for compliance)
  auditLogs           AuditLog[]
  loginAttempts       LoginAttempt[]      @relation("UserLoginAttempts")
  securityAuditLogs   SecurityAuditLog[]  @relation("UserSecurityLogs")
  emailVerifications  EmailVerification[] @relation("UserEmailVerifications")
  analyticsEvents     AnalyticsEvent[]    @relation("UserAnalyticsEvents")
  errorLogs           SystemErrorLog[]    @relation("ErrorLogUser")
  resolvedErrors      SystemErrorLog[]    @relation("ErrorLogResolver")
  attendanceSummaries AttendanceSummary[] @relation("AttendanceSummary")

  @@index([deletedAt])
  @@index([role, status, deletedAt])
  @@index([email])
  @@index([phone])
  @@map("users")
}

model AuthSession {
  id             String    @id @default(cuid())
  userId         String
  fingerprint    String // Merged from DeviceSession
  deviceId       String?
  deviceName     String?
  deviceType     String? // Merged from DeviceSession
  browser        String? // Merged from DeviceSession
  browserVersion String? // Merged from DeviceSession
  os             String? // Merged from DeviceSession
  osVersion      String? // Merged from DeviceSession
  ipAddress      String?
  country        String? // Merged from DeviceSession
  city           String? // Merged from DeviceSession
  latitude       Float? // Merged from DeviceSession
  longitude      Float? // Merged from DeviceSession
  userAgent      String?
  isTrusted      Boolean   @default(false) // Merged from DeviceSession
  lastActiveAt   DateTime  @default(now())
  expiresAt      DateTime
  revokedAt      DateTime?
  revokedReason  String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user          User           @relation("UserSessions", fields: [userId], references: [id], onDelete: Cascade)
  refreshTokens RefreshToken[]

  @@unique([userId, fingerprint])
  @@index([userId])
  @@index([fingerprint])
  @@index([lastActiveAt])
  @@index([expiresAt])
  @@map("auth_sessions")
}

model RefreshToken {
  id            String       @id @default(cuid())
  token         String       @unique
  userId        String
  sessionId     String
  expiresAt     DateTime
  revoked       Boolean      @default(false)
  revokedAt     DateTime?
  revokedReason String?
  deviceId      String?
  ipAddress     String?
  userAgent     String?
  lastUsedAt    DateTime?
  usageCount    Int          @default(0)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  session       AuthSession? @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([sessionId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model AccessTokenBlacklist {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  reason    String?
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([expiresAt])
  @@index([userId])
  @@map("access_token_blacklist")
}

model TeacherProfile {
  id                     String                     @id @default(cuid())
  userId                 String                     @unique
  employeeId             String?                    @unique
  department             String?
  specialization         String?
  experience             Int?
  qualifications         String[]
  canCreateExams         Boolean                    @default(true)
  canMonitorExams        Boolean                    @default(true)
  canManageClasses       Boolean                    @default(true)
  maxStudentsPerClass    Int?
  sourceInstitution      String?
  maxClassesPerWeek      Int?                       @default(20)
  availability           Json?
  certifications         String[]
  performanceRating      Float?
  lastEvaluationDate     DateTime?
  institutionId          String?
  createdAt              DateTime                   @default(now())
  updatedAt              DateTime                   @updatedAt
  institution            Institution?               @relation("TeacherInstitution", fields: [institutionId], references: [id])
  user                   User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  subjectAssignments     TeacherSubjectAssignment[] @relation("TeacherSubjectAssignments")
  // If true, teacher is only allowed to participate in external transfer portal related flows
  isExternalTransferOnly Boolean                    @default(false)

  @@map("teacher_profiles")
}

model TeacherAvailability {
  id                   String      @id @default(cuid())
  teacherId            String
  leaveType            LeaveType
  startDate            DateTime
  endDate              DateTime
  reason               String?
  status               LeaveStatus @default(PENDING)
  replacementTeacherId String?
  replacementApproved  Boolean     @default(false)
  affectedClassIds     String[]
  autoRescheduled      Boolean     @default(false)
  requestedBy          String
  approvedBy           String?
  approvedAt           DateTime?
  rejectedBy           String?
  rejectedAt           DateTime?
  rejectionReason      String?
  notificationSent     Boolean     @default(false)
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  teacher            User  @relation("TeacherLeaves", fields: [teacherId], references: [id])
  replacementTeacher User? @relation("ReplacementTeacher", fields: [replacementTeacherId], references: [id])
  requester          User  @relation("LeaveRequester", fields: [requestedBy], references: [id])
  approver           User? @relation("LeaveApprover", fields: [approvedBy], references: [id])
  rejector           User? @relation("LeaveRejector", fields: [rejectedBy], references: [id])

  @@index([teacherId, startDate, endDate])
  @@index([status])
  @@map("teacher_availability")
}

enum LeaveType {
  SICK_LEAVE
  CASUAL_LEAVE
  EMERGENCY
  PROFESSIONAL_DEVELOPMENT
  PERSONAL
  MATERNITY
  PATERNITY
  VACATION
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum RescheduleStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
  CANCELLED
}

enum RescheduleReason {
  TEACHER_LEAVE
  HOLIDAY
  EMERGENCY
  MAKEUP
  FACILITY_ISSUE
  OTHER
}

model ClassRescheduling {
  id                 String           @id @default(cuid())
  originalClassId    String
  originalDate       DateTime
  originalStartTime  DateTime
  originalEndTime    DateTime
  newDate            DateTime
  newStartTime       DateTime
  newEndTime         DateTime
  teacherId          String
  reason             RescheduleReason
  reasonDetails      String?
  status             RescheduleStatus @default(PENDING)
  studentsNotified   Boolean          @default(false)
  notificationSentAt DateTime?
  conflictResolution String?
  hasConflicts       Boolean          @default(false)
  affectedStudentIds String[]
  requestedBy        String
  approvedBy         String?
  approvedAt         DateTime?
  rejectedBy         String?
  rejectedAt         DateTime?
  rejectionReason    String?
  completedAt        DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  // Relations
  originalClass Class @relation("RescheduledClasses", fields: [originalClassId], references: [id])
  teacher       User  @relation("TeacherRescheduling", fields: [teacherId], references: [id])
  requester     User  @relation("ReschedulingRequests", fields: [requestedBy], references: [id])
  approver      User? @relation("ApprovedReschedulings", fields: [approvedBy], references: [id])
  rejector      User? @relation("RejectedReschedulings", fields: [rejectedBy], references: [id])

  @@index([originalClassId, status])
  @@index([teacherId, status])
  @@index([status, newDate])
  @@map("class_reschedulings")
}

model StudentProfile {
  id                String           @id @default(cuid())
  userId            String           @unique
  studentId         String?          @unique
  gradeId           String?
  mediumId          String?
  batchId           String?
  academicYear      String?
  guardianName      String?
  guardianPhone     String?
  guardianEmail     String?
  currentGPA        Float?
  totalCredits      Int?
  sourceInstitution String?
  schoolName        String?
  preferredSubjects String[]
  previousGrades    Json?
  healthInfo        String?
  // transportMode removed to align with online-only platform
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  grade             Grade?           @relation("StudentProfileGrade", fields: [gradeId], references: [id])
  medium            Medium?          @relation("StudentProfileMedium", fields: [mediumId], references: [id])
  batch             Batch?           @relation(fields: [batchId], references: [id])
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  studentSubjects   StudentSubject[]

  @@index([gradeId])
  @@index([mediumId])
  @@index([gradeId, mediumId])
  @@map("student_profiles")
}

model Class {
  id                  String                    @id @default(cuid())
  name                String
  description         String?
  batchId             String?
  status              ClassStatus               @default(DRAFT)
  maxStudents         Int?
  isPublic            Boolean                   @default(true)
  requiresApproval    Boolean                   @default(false)
  recordingUrl        String?
  materials           String?
  isLive              Boolean                   @default(false)
  startedAt           DateTime?
  endedAt             DateTime?
  fees                Float?                    @default(0)
  isPaid              Boolean?                  @default(false)
  metadata            Json?
  teacherId           String
  subjectId           String
  gradeId             String
  mediumId            String
  teacherAssignmentId String?
  deletedAt           DateTime?
  deletedBy           String?
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt
  deleter             User?                     @relation("ClassDeleters", fields: [deletedBy], references: [id])
  grade               Grade                     @relation("ClassGrade", fields: [gradeId], references: [id])
  subject             Subject                   @relation("ClassSubject", fields: [subjectId], references: [id])
  medium              Medium?                   @relation("ClassMedium", fields: [mediumId], references: [id])
  teacher             User                      @relation("CreatedClasses", fields: [teacherId], references: [id])
  teacherAssignment   TeacherSubjectAssignment? @relation("AssignedClasses", fields: [teacherAssignmentId], references: [id])
  batch               Batch?                    @relation(fields: [batchId], references: [id])
  courseMaterials     CourseMaterial[]
  enrollments         Enrollment[]
  exams               Exam[]
  videoSessions       VideoSession[]
  sessions            ClassSession[]
  attendances         Attendance[]              @relation("ClassAttendance")
  reschedulings       ClassRescheduling[]       @relation("RescheduledClasses")

  @@index([deletedAt])
  @@index([isPublic, status, deletedAt])
  @@index([teacherId, status, deletedAt])
  @@index([subjectId, gradeId, mediumId])
  @@index([gradeId])
  @@index([teacherAssignmentId])
  @@map("classes")
}

model ClassSession {
  id             String        @id @default(cuid())
  classId        String
  timetableId    String?
  date           DateTime
  startTime      DateTime?
  endTime        DateTime?
  status         SessionStatus @default(SCHEDULED)
  videoSessionId String?       @unique

  class        Class         @relation(fields: [classId], references: [id])
  timetable    Timetable?    @relation(fields: [timetableId], references: [id])
  videoSession VideoSession? @relation("ClassSessionVideoSession", fields: [videoSessionId], references: [id])
  attendances  Attendance[]  @relation("ClassSessionAttendance")

  @@index([classId, date])
  @@index([timetableId])
  @@map("class_sessions")
}

model Enrollment {
  id          String           @id @default(cuid())
  classId     String
  studentId   String
  status      EnrollmentStatus @default(PENDING)
  enrolledAt  DateTime         @default(now())
  completedAt DateTime?
  progress    Float            @default(0)
  isPaid      Boolean          @default(false)
  paymentId   String?
  deletedAt   DateTime?
  deletedBy   String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  class       Class            @relation(fields: [classId], references: [id])
  deleter     User?            @relation("EnrollmentDeleters", fields: [deletedBy], references: [id])
  payment     Payment?         @relation(fields: [paymentId], references: [id])
  student     User             @relation(fields: [studentId], references: [id])

  @@unique([classId, studentId])
  @@index([createdAt])
  @@index([status])
  @@index([deletedAt])
  @@index([studentId, status, deletedAt])
  @@index([classId, status])
  @@map("enrollments")
}

model Exam {
  id                       String         @id @default(cuid())
  title                    String
  description              String?
  type                     ExamType
  format                   ExamFormat     @default(FULL_ONLINE)
  status                   ExamStatus     @default(DRAFT)
  approvalStatus           ApprovalStatus @default(PENDING)
  rejectionReason          String?
  approvedById             String?
  approvedAt               DateTime?
  duration                 Int
  totalMarks               Float
  passingMarks             Float
  attemptsAllowed          Int            @default(1)
  part1Marks               Float?
  part2Marks               Float?
  allowFileUpload          Boolean        @default(false)
  maxFileSize              Int?
  allowedFileTypes         String[]
  uploadInstructions       String?
  windowStart              DateTime?
  windowEnd                DateTime?
  lateSubmissionAllowed    Boolean        @default(false)
  latePenaltyPercent       Float?
  enableRanking            Boolean        @default(false)
  rankingLevels            RankingLevel[]
  aiMonitoringEnabled      Boolean        @default(false)
  faceVerificationRequired Boolean        @default(false)
  browseLockEnabled        Boolean        @default(false)
  useHierarchicalStructure Boolean        @default(false)
  randomizeQuestions       Boolean        @default(false)
  randomizeOptions         Boolean        @default(false)
  showResults              Boolean        @default(true)
  // Who can access the exam
  visibility               ExamVisibility @default(BOTH)
  startTime                DateTime
  endTime                  DateTime
  timeZone                 String?
  classId                  String?
  createdById              String?
  subjectId                String
  gradeId                  String
  mediumId                 String
  academicYearId           String?
  instructions             String?
  allowedResources         String?
  deletedAt                DateTime?
  deletedBy                String?
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  attempts                 ExamAttempt[]
  questions                ExamQuestion[]
  sections                 ExamSection[]
  rankings                 ExamRanking[]
  approver                 User?          @relation("ExamApprover", fields: [approvedById], references: [id])
  class                    Class?         @relation(fields: [classId], references: [id])
  creator                  User?          @relation("ExamCreator", fields: [createdById], references: [id])
  deleter                  User?          @relation("ExamDeleters", fields: [deletedBy], references: [id])
  grade                    Grade          @relation("ExamGrade", fields: [gradeId], references: [id])
  subject                  Subject        @relation("ExamSubject", fields: [subjectId], references: [id])
  medium                   Medium?        @relation("ExamMedium", fields: [mediumId], references: [id])
  academicYear             AcademicYear?  @relation(fields: [academicYearId], references: [id])
  attendances              Attendance[]   @relation("ExamAttendance")

  @@index([deletedAt])
  @@index([status, startTime, deletedAt])
  @@index([createdById, status, deletedAt])
  @@index([classId, status, deletedAt])
  @@index([subjectId, gradeId, mediumId])
  @@index([gradeId])
  @@map("exams")
}

model PaymentReconciliation {
  id                     String               @id @default(cuid())
  paymentId              String?              @unique
  trackerPlusRefId       String               @unique
  trackerPlusAmount      Float
  trackerPlusDate        DateTime
  trackerPlusStudentId   String?
  trackerPlusStudentName String?
  trackerPlusDescription String?
  trackerPlusMetadata    String? // JSON string for additional TrackerPlus data
  internalAmount         Float?
  internalDate           DateTime?
  status                 ReconciliationStatus @default(PENDING)
  type                   ReconciliationType   @default(UNMATCHED)
  discrepancyAmount      Float?
  discrepancyReason      String?
  matchedBy              String?
  matchedAt              DateTime?
  notes                  String?
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt

  payment Payment? @relation("PaymentReconciliation", fields: [paymentId], references: [id], onDelete: SetNull)
  matcher User?    @relation("ReconciliationMatchers", fields: [matchedBy], references: [id])

  @@index([status])
  @@index([type])
  @@index([trackerPlusDate])
  @@index([matchedAt])
  @@map("payment_reconciliations")
}

model ExamQuestion {
  id             String         @id @default(cuid())
  examId         String
  sectionId      String?
  groupId        String?
  type           QuestionType
  question       String
  options        Json?          @db.Json // Standardized to JSON like Question bank
  correctAnswer  String?
  matchingPairs  Json?          @db.Json // Standardized to JSON
  parts          Json?          @db.Json // Standardized to JSON
  subQuestions   Json?          @db.Json // Standardized to JSON
  points         Float          @default(1)
  order          Int
  examPart       Int            @default(1)
  section        String?        @default("PART_I")
  imageUrl       String?
  videoUrl       String?
  attachmentUrl  String?
  answerImageUrl String?
  optionImages   Json?          @db.Json // Standardized to JSON
  showNumber     Boolean        @default(true)
  numbering      String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  answers        ExamAnswer[]
  exam           Exam           @relation(fields: [examId], references: [id], onDelete: Cascade)
  examSection    ExamSection?   @relation("SectionQuestions", fields: [sectionId], references: [id], onDelete: SetNull)
  questionGroup  QuestionGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([examId])
  @@index([sectionId])
  @@index([groupId])
  @@map("exam_questions")
}

model ExamSection {
  id                  String          @id @default(cuid())
  examId              String
  title               String
  description         String?
  order               Int
  examPart            Int             @default(1)
  defaultQuestionType QuestionType?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  exam                Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  questions           ExamQuestion[]  @relation("SectionQuestions")
  groups              QuestionGroup[]

  @@index([examId, order])
  @@map("exam_sections")
}

model QuestionGroup {
  id          String         @id @default(cuid())
  sectionId   String
  title       String
  instruction String?
  order       Int
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  section     ExamSection    @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  questions   ExamQuestion[]

  @@index([sectionId, order])
  @@map("question_groups")
}

model ExamAttempt {
  id                      String          @id @default(cuid())
  examId                  String
  studentId               String
  status                  AttemptStatus   @default(STARTED)
  attemptNumber           Int
  startedAt               DateTime        @default(now())
  submittedAt             DateTime?
  timeSpent               Int?
  totalScore              Float?
  part1Score              Float?
  part2Score              Float?
  maxScore                Float
  percentage              Float?
  passed                  Boolean?
  uploadedFiles           String[]
  uploadedAt              DateTime?
  correctedBy             String?
  correctedAt             DateTime?
  correctionNotes         String?
  islandRank              Int?
  districtRank            Int?
  zoneRank                Int?
  faceVerificationScore   Float?
  suspiciousActivityCount Int             @default(0)
  monitoringData          String?
  flaggedReasons          String?
  browserInfo             String?
  deviceInfo              String?
  ipAddress               String?
  isLocked                Boolean         @default(false)
  lockedReason            String?
  lockedAt                DateTime?
  unlockedBy              String?
  unlockedAt              DateTime?
  createdAt               DateTime        @default(now())
  updatedAt               DateTime        @updatedAt
  answers                 ExamAnswer[]
  corrector               User?           @relation("ExamCorrectors", fields: [correctedBy], references: [id])
  exam                    Exam            @relation(fields: [examId], references: [id])
  student                 User            @relation(fields: [studentId], references: [id])
  unlocker                User?           @relation("ExamAttemptUnlockers", fields: [unlockedBy], references: [id])
  proctoringLogs          ProctoringLog[]

  @@unique([examId, studentId, attemptNumber])
  @@index([examId, studentId])
  @@index([submittedAt])
  @@index([status])
  @@map("exam_attempts")
}

model ExamAnswer {
  id            String       @id @default(cuid())
  attemptId     String
  questionId    String
  answer        String
  isCorrect     Boolean?
  pointsAwarded Float?
  timeSpent     Int?
  answeredAt    DateTime     @default(now())
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  attempt       ExamAttempt  @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question      ExamQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([attemptId, questionId])
  @@map("exam_answers")
}

model ExamRanking {
  id            String       @id @default(cuid())
  examId        String
  studentId     String
  student       User         @relation(fields: [studentId], references: [id], onDelete: Cascade)
  studentType   StudentType?
  score         Float
  percentage    Float
  district      String?
  zone          String?
  islandRank    Int
  districtRank  Int?
  zoneRank      Int?
  totalIsland   Int
  totalDistrict Int?
  totalZone     Int?
  calculatedAt  DateTime     @default(now())
  exam          Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@unique([examId, studentId])
  @@index([examId, islandRank])
  @@index([examId, district, districtRank])
  @@index([examId, zone, zoneRank])
  @@index([examId, studentType])
  @@map("exam_rankings")
}

model Payment {
  id                      String                 @id @default(cuid())
  userId                  String
  amount                  Float
  currency                String                 @default("LKR")
  status                  PaymentStatus          @default(PENDING)
  method                  PaymentMethod
  bankSlipUrl             String?
  bankSlipVerifiedBy      String?
  bankSlipVerifiedAt      DateTime?
  bankSlipRejectionReason String?
  gatewayTransactionId    String?
  gatewayResponse         String?
  description             String?
  metadata                Json?
  referenceType           String?
  referenceId             String?
  refundAmount            Float?
  refundReason            String?
  refundedAt              DateTime?
  processedAt             DateTime?
  createdAt               DateTime               @default(now())
  updatedAt               DateTime               @updatedAt
  enrollments             Enrollment[]
  reconciliation          PaymentReconciliation? @relation("PaymentReconciliation")
  user                    User                   @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@index([status])
  @@index([userId, status, createdAt])
  @@index([status, createdAt])
  @@index([referenceType, referenceId])
  @@map("payments")
}

model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  studentId     String
  type          InvoiceType
  status        InvoiceStatus @default(PENDING)
  items         Json
  subtotal      Float
  tax           Float         @default(0)
  discount      Float         @default(0)
  total         Float
  dueDate       DateTime
  issuedDate    DateTime      @default(now())
  paidAt        DateTime?
  paymentId     String?
  sentAt        DateTime?
  notes         String?
  metadata      Json?
  createdById   String
  deletedAt     DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  student       User          @relation("StudentInvoices", fields: [studentId], references: [id])
  createdBy     User          @relation("InvoiceCreators", fields: [createdById], references: [id])

  @@index([studentId])
  @@index([status])
  @@index([type])
  @@index([issuedDate])
  @@index([dueDate])
  @@index([deletedAt])
  @@index([studentId, status, deletedAt])
  @@map("invoices")
}

model VideoSession {
  id                  String               @id @default(cuid())
  classId             String
  hostId              String
  title               String
  description         String?
  status              SessionStatus        @default(SCHEDULED)
  scheduledStartTime  DateTime?
  durationMinutes     Int
  startedAt           DateTime?
  endedAt             DateTime?
  actualDuration      Int?
  jitsiRoomName       String               @unique
  jitsiDomain         String               @default("meet.jit.si")
  muteAll             Boolean              @default(false)
  videoDisabled       Boolean              @default(false)
  locked              Boolean              @default(false)
  recordSession       Boolean              @default(false)
  recordingUrl        String?
  recordingDeleteAt   DateTime?
  maxParticipants     Int                  @default(50)
  currentParticipants Int                  @default(0)
  createdById         String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  recordings          Recording[]
  participants        SessionParticipant[]
  class               Class                @relation(fields: [classId], references: [id])
  creator             User?                @relation("VideoSessionCreator", fields: [createdById], references: [id])
  host                User                 @relation("SessionHost", fields: [hostId], references: [id])
  classSession        ClassSession?        @relation("ClassSessionVideoSession")
  attendances         Attendance[]         @relation("VideoSessionAttendance")

  @@index([classId, status])
  @@index([scheduledStartTime])
  @@index([recordingDeleteAt])
  @@map("video_sessions")
}

model SessionParticipant {
  id           String       @id @default(cuid())
  sessionId    String
  userId       String
  joinedAt     DateTime     @default(now())
  leftAt       DateTime?
  duration     Int?
  lastActivity DateTime     @default(now())
  muteCount    Int          @default(0)
  unmuteCount  Int          @default(0)
  session      VideoSession @relation(fields: [sessionId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@unique([sessionId, userId])
  @@index([sessionId, joinedAt])
  @@map("session_participants")
}

model Notification {
  id          String             @id @default(cuid())
  userId      String
  type        NotificationType
  status      NotificationStatus @default(UNREAD)
  title       String
  message     String
  data        String?
  sentAt      DateTime? // Single tick - message sent to server
  deliveredAt DateTime? // Double tick - delivered to device
  readAt      DateTime? // Double blue tick - read by user
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  user        User               @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@index([userId, createdAt])
  @@map("notifications")
}

model ScheduledNotification {
  id           String                      @id @default(cuid())
  userId       String
  title        String
  body         String
  data         String? // JSON data for deep linking
  triggerType  String // exam_reminder, class_reminder, payment_due, etc.
  referenceId  String? // examId, classId, etc.
  scheduledFor DateTime
  priority     String                      @default("normal") // high, normal
  status       ScheduledNotificationStatus @default(PENDING)
  processedAt  DateTime?
  errorMessage String?
  createdAt    DateTime                    @default(now())
  updatedAt    DateTime                    @updatedAt

  @@index([status, scheduledFor])
  @@index([userId])
  @@index([referenceId])
  @@index([triggerType])
  @@map("scheduled_notifications")
}

enum ScheduledNotificationStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}

model DeviceToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  platform  String // 'web', 'android', 'ios'
  deviceId  String?
  isActive  Boolean  @default(true)
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation("UserDeviceTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([isActive])
  @@map("device_tokens")
}

model AuditLog {
  id         String      @id @default(cuid())
  userId     String?
  action     AuditAction
  resource   String
  resourceId String?
  ipAddress  String?
  userAgent  String?
  endpoint   String?
  httpMethod String?
  oldValues  String?
  newValues  String?
  metadata   String?
  createdAt  DateTime    @default(now())
  user       User?       @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

model Publication {
  id               String                @id @default(cuid())
  title            String
  description      String
  shortDescription String?
  coverImage       String?
  price            Float
  discountPrice    Float?
  fileUrl          String
  fileSize         Int?
  fileType         String?
  previewUrl       String?
  author           String?
  publisher        String?
  isbn             String?
  status           PublicationStatus     @default(DRAFT)
  publishedAt      DateTime?
  createdById      String?
  downloads        Int                   @default(0)
  views            Int                   @default(0)
  rating           Float?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  creator          User?                 @relation("PublicationCreator", fields: [createdById], references: [id])
  grades           PublicationGrade[]
  subjects         PublicationSubject[]
  mediums          PublicationMedium[]
  purchases        PublicationPurchase[]
  reviews          PublicationReview[]

  @@index([status])
  @@index([createdAt])
  @@map("publications")
}

model PublicationPurchase {
  id             String      @id @default(cuid())
  publicationId  String
  userId         String
  amount         Float
  paymentId      String?
  accessExpiry   DateTime?
  downloadCount  Int         @default(0)
  maxDownloads   Int?
  purchasedAt    DateTime    @default(now())
  lastAccessedAt DateTime?
  publication    Publication @relation(fields: [publicationId], references: [id])
  user           User        @relation("PublicationPurchases", fields: [userId], references: [id])

  @@unique([publicationId, userId])
  @@map("publication_purchases")
}

model PublicationReview {
  id            String      @id @default(cuid())
  publicationId String
  userId        String
  rating        Int
  comment       String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  publication   Publication @relation(fields: [publicationId], references: [id])
  user          User        @relation("PublicationReviews", fields: [userId], references: [id])

  @@unique([publicationId, userId])
  @@map("publication_reviews")
}

model TransferRequest {
  id          String @id @default(cuid())
  uniqueId    String @unique
  requesterId String
  fromZoneId  String
  subjectId   String
  mediumId    String
  level       String

  currentSchool          String?
  currentSchoolType      String?
  currentDistrictId      String?
  yearsOfService         Int?
  qualifications         String[]
  isInternalTeacher      Boolean  @default(true)
  preferredSchoolTypes   String[]
  additionalRequirements String?

  status            TransferRequestStatus @default(PENDING)
  approvalStatus    ApprovalStatus        @default(PENDING)
  verified          Boolean               @default(false)
  verifiedBy        String?
  verifiedAt        DateTime?
  verificationNotes String?
  notes             String?
  attachments       String[]
  version           Int                   @default(0)
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  completedAt       DateTime?
  acceptanceNotes   String?

  fromZone        Zone                         @relation("TransferFromZone", fields: [fromZoneId], references: [id], onDelete: Restrict)
  currentDistrict District?                    @relation("TransferCurrentDistrict", fields: [currentDistrictId], references: [id], onDelete: SetNull)
  subject         Subject                      @relation("TransferRequestSubject", fields: [subjectId], references: [id], onDelete: Restrict)
  medium          Medium                       @relation("TransferRequestMedium", fields: [mediumId], references: [id], onDelete: Restrict)
  requester       User                         @relation("TransferRequester", fields: [requesterId], references: [id])
  verifier        User?                        @relation("TransferVerifier", fields: [verifiedBy], references: [id])
  desiredZones    TransferRequestDesiredZone[]
  messages        TransferMessage[]
  acceptances     TransferAcceptance[]

  @@index([status, verified])
  @@index([fromZoneId])
  @@index([currentDistrictId])
  @@index([currentSchoolType])
  @@index([isInternalTeacher])
  @@index([subjectId, mediumId])
  @@index([requesterId])
  @@map("transfer_requests")
}

model TransferAcceptance {
  id                String         @id @default(cuid())
  transferRequestId String
  acceptorId        String
  status            ApprovalStatus @default(PENDING)
  notes             String?
  acceptedAt        DateTime?
  rejectedAt        DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  request  TransferRequest @relation(fields: [transferRequestId], references: [id], onDelete: Cascade)
  acceptor User            @relation("TransferAcceptor", fields: [acceptorId], references: [id])

  @@unique([transferRequestId, acceptorId])
  @@index([acceptorId])
  @@index([status])
  @@map("transfer_acceptances")
}

model TransferMessage {
  id                String          @id @default(cuid())
  transferRequestId String
  senderId          String
  content           String
  read              Boolean         @default(false)
  readAt            DateTime?
  createdAt         DateTime        @default(now())
  sender            User            @relation("TransferMessageSender", fields: [senderId], references: [id])
  request           TransferRequest @relation(fields: [transferRequestId], references: [id], onDelete: Cascade)

  @@map("transfer_messages")
}

model Timetable {
  id                  String                   @id @default(cuid())
  teacherId           String
  subjectId           String
  gradeId             String
  mediumId            String
  teacherAssignmentId String
  classLink           String
  classId             String?
  dayOfWeek           Int
  startTime           String
  endTime             String
  validFrom           DateTime
  validUntil          DateTime
  recurring           Boolean                  @default(true)
  active              Boolean                  @default(true)
  academicYearId      String?
  term                Int                      @default(1)
  batchId             String?
  color               String?
  notes               String?
  recurrencePattern   String?
  excludeDates        String?
  createdBy           String?
  lastModifiedBy      String?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt
  grade               Grade                    @relation("TimetableGrade", fields: [gradeId], references: [id], onDelete: Restrict)
  medium              Medium                   @relation("TimetableMedium", fields: [mediumId], references: [id], onDelete: Restrict)
  subject             Subject                  @relation("TimetableSubject", fields: [subjectId], references: [id], onDelete: Restrict)
  teacher             User                     @relation("TimetableTeacher", fields: [teacherId], references: [id])
  teacherAssignment   TeacherSubjectAssignment @relation("TimetableTeacherAssignment", fields: [teacherAssignmentId], references: [id], onDelete: Restrict)
  academicYear        AcademicYear?            @relation(fields: [academicYearId], references: [id])
  batch               Batch?                   @relation(fields: [batchId], references: [id])
  changes             TimetableChange[]
  sessions            ClassSession[]

  @@index([gradeId, academicYearId, term, dayOfWeek])
  @@index([teacherId, dayOfWeek])
  @@index([teacherAssignmentId])
  @@index([academicYearId, term])
  @@index([subjectId, gradeId, mediumId])
  @@map("timetable")
}

model TimetableChange {
  id               String     @id @default(cuid())
  timetableId      String
  changeType       ChangeType
  changeDate       DateTime
  newSubject       String?
  newTeacherId     String?
  newStartTime     String?
  newEndTime       String?
  newClassLink     String?
  reason           String?
  notificationSent Boolean    @default(false)
  createdBy        String
  createdAt        DateTime   @default(now())
  creator          User       @relation("ChangeCreator", fields: [createdBy], references: [id])
  newTeacher       User?      @relation("newTeacherId", fields: [newTeacherId], references: [id])
  timetable        Timetable  @relation(fields: [timetableId], references: [id], onDelete: Cascade)

  @@index([changeDate])
  @@map("timetable_changes")
}

model Attendance {
  id             String         @id @default(cuid())
  userId         String
  date           DateTime
  type           AttendanceType @default(CLASS)
  classId        String?
  classSessionId String?
  examId         String?
  videoSessionId String?
  present        Boolean        @default(false)
  joinTime       DateTime?
  leaveTime      DateTime?
  duration       Int?
  notes          String?
  markedBy       String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  user           User           @relation("AttendanceUser", fields: [userId], references: [id])
  class          Class?         @relation("ClassAttendance", fields: [classId], references: [id])
  classSession   ClassSession?  @relation("ClassSessionAttendance", fields: [classSessionId], references: [id])
  exam           Exam?          @relation("ExamAttendance", fields: [examId], references: [id])
  videoSession   VideoSession?  @relation("VideoSessionAttendance", fields: [videoSessionId], references: [id])

  @@unique([userId, date, type, classSessionId, examId, videoSessionId])
  @@index([userId, date])
  @@index([date])
  @@index([classId])
  @@index([examId])
  @@map("attendance")
}

model AttendanceSummary {
  id              String   @id @default(cuid())
  userId          String
  month           Int
  year            Int
  totalClasses    Int
  attended        Int
  percentage      Float
  classesTotal    Int      @default(0)
  classesAttended Int      @default(0)
  examsTotal      Int      @default(0)
  examsAttended   Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation("AttendanceSummary", fields: [userId], references: [id])

  @@unique([userId, month, year])
  @@map("attendance_summary")
}

model Wallet {
  id           String              @id @default(cuid())
  userId       String              @unique
  balance      Float               @default(0)
  totalCredits Float               @default(0)
  totalDebits  Float               @default(0)
  maxBalance   Float?
  minBalance   Float               @default(0)
  frozen       Boolean             @default(false)
  frozenReason String?
  frozenAt     DateTime?
  lastTopUp    DateTime?
  version      Int                 @default(0)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  transactions WalletTransaction[]
  user         User                @relation("UserWallet", fields: [userId], references: [id])

  @@map("wallets")
}

model WalletTransaction {
  id            String          @id @default(cuid())
  walletId      String
  amount        Float
  type          TransactionType
  balanceBefore Float
  balanceAfter  Float
  description   String
  reference     String? // Payment ID or other reference
  referenceType String? // 'PAYMENT', 'REFUND', 'TOPUP', etc.
  metadata      Json?           @db.Json
  createdAt     DateTime        @default(now())
  wallet        Wallet          @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId, createdAt])
  @@index([referenceType, reference])
  @@map("wallet_transactions")
}

model TemporaryAccess {
  id               String                  @id @default(cuid())
  userId           String
  grantedBy        String
  resourceType     TemporaryAccessResource
  resourceId       String
  startDate        DateTime
  expiresAt        DateTime
  reason           String?
  active           Boolean                 @default(true)
  revokedBy        String?
  revokedAt        DateTime?
  revocationNote   String?
  notificationSent Boolean                 @default(false)
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt

  grantor User  @relation("AccessGrantor", fields: [grantedBy], references: [id])
  user    User  @relation("TemporaryAccessUser", fields: [userId], references: [id])
  revoker User? @relation("AccessRevoker", fields: [revokedBy], references: [id])

  @@unique([userId, resourceType, resourceId])
  @@index([userId, expiresAt, active])
  @@index([resourceType, resourceId])
  @@map("temporary_access")
}

enum TemporaryAccessResource {
  EXAM
  CLASS
  COURSE_MATERIAL
  VIDEO_RECORDING
  ASSIGNMENT
}

model AnalyticsEvent {
  id         String   @id @default(cuid())
  userId     String?
  event      String
  properties Json?
  sessionId  String?
  ipAddress  String?
  userAgent  String?
  timestamp  DateTime @default(now())
  user       User?    @relation("UserAnalyticsEvents", fields: [userId], references: [id])

  @@index([userId, timestamp])
  @@index([event, timestamp])
  @@index([sessionId, timestamp])
  @@map("analytics_events")
}

model ChatMessage {
  id              String                @id @default(cuid())
  fromId          String
  toId            String
  messageType     ChatMessageType       @default(DIRECT)
  content         String
  attachments     String[]
  approvalStatus  MessageApprovalStatus @default(PENDING)
  approvedBy      String?
  approvedAt      DateTime?
  rejectionReason String?
  readAt          DateTime?
  deleted         Boolean               @default(false)
  deletedAt       DateTime?
  metadata        Json?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  approver        User?                 @relation("MessagesApproved", fields: [approvedBy], references: [id])
  from            User                  @relation("MessagesSent", fields: [fromId], references: [id])
  to              User                  @relation("MessagesReceived", fields: [toId], references: [id])

  @@index([fromId, toId])
  @@index([approvalStatus])
  @@index([createdAt])
  @@map("chat_messages")
}

model Announcement {
  id          String               @id @default(cuid())
  title       String
  content     String
  type        AnnouncementType     @default(GENERAL)
  priority    AnnouncementPriority @default(NORMAL)
  targetRoles String[]
  isActive    Boolean              @default(true)
  publishedAt DateTime?
  expiresAt   DateTime?
  createdById String
  attachments String[]
  metadata    Json?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @default(now())
  creator     User                 @relation("AnnouncementsCreated", fields: [createdById], references: [id])
  grades      AnnouncementGrade[]
  reads       AnnouncementRead[]

  @@index([isActive, publishedAt])
  @@index([expiresAt])
  @@map("announcements")
}

model AnnouncementRead {
  id             String       @id @default(cuid())
  announcementId String
  userId         String
  readAt         DateTime     @default(now())
  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)

  @@unique([announcementId, userId])
  @@map("announcement_reads")
}

model CourseMaterial {
  id           String                @id @default(cuid())
  classId      String?
  subjectId    String?
  title        String
  description  String?
  type         MaterialType
  fileUrl      String
  fileSize     Int?
  fileType     String?
  thumbnailUrl String?
  isPublic     Boolean               @default(false)
  uploadedById String
  downloads    Int                   @default(0)
  views        Int                   @default(0)
  validFrom    DateTime?
  validUntil   DateTime?
  metadata     Json?
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  class        Class?                @relation(fields: [classId], references: [id])
  subject      Subject?              @relation("CourseMaterialSubject", fields: [subjectId], references: [id])
  uploader     User                  @relation("MaterialsUploaded", fields: [uploadedById], references: [id])
  grades       CourseMaterialGrade[]

  @@index([classId])
  @@index([subjectId])
  @@index([isPublic])
  @@index([uploadedById])
  @@map("course_materials")
}

model FaceRecognition {
  id                String    @id @default(cuid())
  userId            String    @unique
  faceEncodingData  String
  faceImageUrl      String?
  frontViewUrl      String?
  leftViewUrl       String?
  rightViewUrl      String?
  verificationVideo String?
  verified          Boolean   @default(false)
  verifiedBy        String?
  verifiedAt        DateTime?
  failedAttempts    Int       @default(0)
  lastVerifiedAt    DateTime?
  metadata          Json?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  user              User      @relation("UserFaceRecognition", fields: [userId], references: [id])

  @@index([verified])
  @@index([userId, verified])
  @@map("face_recognition")
}

model ProctoringLog {
  id                String              @id @default(cuid())
  attemptId         String
  eventType         ProctoringEventType
  severity          SeverityLevel       @default(INFO)
  description       String?
  snapshotUrl       String?
  faceMatchScore    Float?
  tabSwitchCount    Int?
  suspiciousActions String[]
  timestamp         DateTime            @default(now())
  metadata          Json?
  attempt           ExamAttempt         @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  @@index([attemptId, timestamp])
  @@index([eventType])
  @@index([severity])
  @@map("proctoring_logs")
}

model Recording {
  id                String           @id @default(cuid())
  sessionId         String
  classId           String?
  title             String
  description       String?
  recordingUrl      String
  thumbnailUrl      String?
  duration          Int?
  fileSize          Int?
  format            String?
  quality           String?
  isProcessed       Boolean          @default(false)
  processingStatus  ProcessingStatus @default(PENDING)
  availableFrom     DateTime         @default(now())
  availableUntil    DateTime
  autoDeleteAt      DateTime
  downloadable      Boolean          @default(true)
  accessRestriction String?
  views             Int              @default(0)
  downloads         Int              @default(0)
  metadata          Json?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  session           VideoSession     @relation(fields: [sessionId], references: [id])

  @@index([sessionId])
  @@index([autoDeleteAt])
  @@index([processingStatus])
  @@map("recordings")
}

model Seminar {
  id              String                @id @default(cuid())
  title           String
  description     String?
  speakerName     String?
  speakerBio      String?
  speakerImage    String?
  coverImage      String?
  topic           String?
  targetAudience  String[]
  scheduledAt     DateTime
  duration        Int
  meetingLink     String?
  isPublic        Boolean               @default(true)
  requiresSignup  Boolean               @default(false)
  maxParticipants Int?
  status          SeminarStatus         @default(SCHEDULED)
  recordingUrl    String?
  materials       String[]
  createdById     String
  metadata        Json?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  registrations   SeminarRegistration[]
  creator         User                  @relation("SeminarsCreated", fields: [createdById], references: [id])

  @@index([scheduledAt])
  @@index([status])
  @@map("seminars")
}

model SeminarRegistration {
  id        String    @id @default(cuid())
  seminarId String
  userId    String?
  name      String?
  email     String?
  phone     String?
  attended  Boolean   @default(false)
  joinedAt  DateTime?
  leftAt    DateTime?
  metadata  Json?
  createdAt DateTime  @default(now())
  seminar   Seminar   @relation(fields: [seminarId], references: [id], onDelete: Cascade)

  @@unique([seminarId, userId])
  @@unique([seminarId, email])
  @@map("seminar_registrations")
}

model Feedback {
  id          String         @id @default(cuid())
  userId      String
  type        FeedbackType
  referenceId String?
  rating      Int?
  comment     String?
  status      FeedbackStatus @default(PENDING)
  respondedBy String?
  response    String?
  respondedAt DateTime?
  metadata    Json?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  user        User           @relation("FeedbacksGiven", fields: [userId], references: [id])

  @@index([type, referenceId])
  @@index([status])
  @@map("feedbacks")
}

model Grade {
  id                   String                     @id @default(cuid())
  name                 String                     @unique
  code                 String?                    @unique
  level                Int                        @unique
  sortOrder            Int                        @default(0)
  description          String?
  isActive             Boolean                    @default(true)
  createdAt            DateTime                   @default(now())
  updatedAt            DateTime                   @updatedAt
  batches              Batch[]
  classes              Class[]                    @relation("ClassGrade")
  exams                Exam[]                     @relation("ExamGrade")
  studentProfiles      StudentProfile[]           @relation("StudentProfileGrade")
  teacherAssignments   TeacherSubjectAssignment[] @relation("GradeAssignments")
  gradeSubjects        GradeSubject[]
  timetables           Timetable[]                @relation("TimetableGrade")
  courseMaterialGrades CourseMaterialGrade[]      @relation("CourseMaterialGrades")
  publicationGrades    PublicationGrade[]         @relation("PublicationGrades")
  announcementGrades   AnnouncementGrade[]        @relation("AnnouncementGrades")
  chapters             SubjectChapter[]           @relation("ChapterGrade")

  @@index([level, isActive])
  @@index([sortOrder, isActive])
  @@map("grades")
}

model Province {
  id        String     @id @default(cuid())
  name      String     @unique
  code      String?    @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  sortOrder Int        @default(0)
  districts District[]

  @@map("provinces")
}

model District {
  id                       String            @id @default(cuid())
  name                     String            @unique
  code                     String?           @unique
  provinceId               String?
  createdAt                DateTime          @default(now())
  updatedAt                DateTime          @updatedAt
  sortOrder                Int               @default(0)
  province                 Province?         @relation(fields: [provinceId], references: [id])
  zones                    Zone[]
  users                    User[]            @relation("UserDistrict")
  transferCurrentDistricts TransferRequest[] @relation("TransferCurrentDistrict")

  @@map("districts")
}

model Zone {
  id                          String                       @id @default(cuid())
  name                        String                       @unique
  code                        String?                      @unique
  districtId                  String?
  createdAt                   DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  sortOrder                   Int                          @default(0)
  district                    District?                    @relation(fields: [districtId], references: [id])
  users                       User[]                       @relation("UserZone")
  institutions                Institution[]                @relation("InstitutionZone")
  transferFromZones           TransferRequest[]            @relation("TransferFromZone")
  transferRequestDesiredZones TransferRequestDesiredZone[] @relation("TransferDesiredZones")

  @@map("zones")
}

model Medium {
  id                 String                     @id @default(cuid())
  name               String                     @unique
  code               String?                    @unique
  description        String?
  isActive           Boolean                    @default(true)
  sortOrder          Int                        @default(0)
  createdAt          DateTime                   @default(now())
  updatedAt          DateTime                   @updatedAt
  classes            Class[]                    @relation("ClassMedium")
  exams              Exam[]                     @relation("ExamMedium")
  studentProfiles    StudentProfile[]           @relation("StudentProfileMedium")
  teacherAssignments TeacherSubjectAssignment[] @relation("MediumAssignments")
  timetables         Timetable[]                @relation("TimetableMedium")
  transferRequests   TransferRequest[]          @relation("TransferRequestMedium")
  publicationMediums PublicationMedium[]        @relation("PublicationMediums")
  subjectMediums     SubjectMedium[]

  @@map("mediums")
}

model GradeSubject {
  id        String   @id @default(cuid())
  gradeId   String
  subjectId String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  grade   Grade   @relation(fields: [gradeId], references: [id], onDelete: Cascade)
  subject Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([gradeId, subjectId])
  @@index([gradeId])
  @@index([subjectId])
  @@map("grade_subjects")
}

model SubjectMedium {
  id        String   @id @default(cuid())
  subjectId String
  mediumId  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subject Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  medium  Medium  @relation(fields: [mediumId], references: [id], onDelete: Cascade)

  @@unique([subjectId, mediumId])
  @@index([subjectId])
  @@index([mediumId])
  @@map("subject_mediums")
}

model StudentSubject {
  id               String   @id @default(cuid())
  studentProfileId String
  subjectId        String
  academicYearId   String
  isActive         Boolean  @default(true)
  enrolledAt       DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  studentProfile StudentProfile @relation(fields: [studentProfileId], references: [id], onDelete: Cascade)
  academicYear   AcademicYear   @relation(fields: [academicYearId], references: [id])
  subject        Subject        @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([studentProfileId, subjectId, academicYearId])
  @@index([studentProfileId])
  @@index([subjectId])
  @@index([academicYearId])
  @@map("student_subjects")
}

model AcademicYear {
  id        String   @id @default(cuid())
  year      String   @unique
  startDate DateTime
  endDate   DateTime
  isCurrent Boolean  @default(false)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  sortOrder Int      @default(0)

  studentSubjects    StudentSubject[]
  teacherAssignments TeacherSubjectAssignment[]
  timetableEntries   Timetable[]
  exams              Exam[]

  @@index([isCurrent, isActive])
  @@map("academic_years")
}

model Batch {
  id              String           @id @default(cuid())
  name            String
  code            String
  gradeId         String
  description     String?
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  sortOrder       Int              @default(0)
  grade           Grade            @relation(fields: [gradeId], references: [id], onDelete: Cascade)
  classes         Class[]
  studentProfiles StudentProfile[]
  timetables      Timetable[]

  @@unique([gradeId, code])
  @@index([gradeId, isActive])
  @@map("batches")
}

model StudentProgress {
  id               String    @id @default(cuid())
  studentId        String    @unique
  currentGPA       Float?
  cumulativeGPA    Float?
  totalCredits     Int       @default(0)
  completedCourses Int       @default(0)
  ongoingCourses   Int       @default(0)
  attendanceRate   Float?
  rank             Int?
  totalStudents    Int?
  lastCalculated   DateTime  @default(now())
  academicYear     String?
  deletedAt        DateTime?
  deletedBy        String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  deletedByUser    User?     @relation("StudentProgressDeleters", fields: [deletedBy], references: [id])
  student          User      @relation("StudentProgressRecord", fields: [studentId], references: [id])

  @@index([currentGPA])
  @@index([rank])
  @@index([academicYear, deletedAt])
  @@map("student_progress")
}

model SystemSettings {
  id          String      @id @default(cuid())
  key         String      @unique
  value       String
  type        SettingType @default(STRING)
  category    String?
  description String?
  isPublic    Boolean     @default(false)
  isEditable  Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  updatedBy   String?

  @@index([category])
  @@index([key, category])
  @@map("system_settings")
}

model FeatureFlag {
  id                String   @id @default(cuid())
  name              String   @unique
  key               String   @unique
  enabled           Boolean  @default(false)
  description       String?
  rolloutPercentage Int      @default(0)
  targetRoles       String[]
  targetUsers       String[]
  metadata          Json?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  createdBy         String?
  updatedBy         String?

  @@index([enabled])
  @@index([key, enabled])
  @@map("feature_flags")
}

model LoginAttempt {
  id            String   @id @default(cuid())
  userId        String?
  identifier    String
  ipAddress     String
  userAgent     String?
  fingerprint   String?
  success       Boolean
  failureReason String?
  country       String?
  city          String?
  riskScore     Int      @default(0)
  createdAt     DateTime @default(now())
  user          User?    @relation("UserLoginAttempts", fields: [userId], references: [id], onDelete: Cascade)

  @@index([identifier, createdAt])
  @@index([ipAddress, createdAt])
  @@index([userId, createdAt])
  @@index([success])
  @@map("login_attempts")
}

model AccountLockout {
  id           String    @id @default(cuid())
  userId       String    @unique
  lockedAt     DateTime  @default(now())
  unlockAt     DateTime
  reason       String
  attemptCount Int
  ipAddress    String?
  autoUnlock   Boolean   @default(true)
  unlockedAt   DateTime?
  unlockedBy   String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  user         User      @relation("UserAccountLockout", fields: [userId], references: [id], onDelete: Cascade)

  @@index([unlockAt])
  @@index([lockedAt])
  @@map("account_lockouts")
}

model EmailVerification {
  id         String    @id @default(cuid())
  userId     String
  email      String
  token      String    @unique
  code       String?
  expiresAt  DateTime
  verified   Boolean   @default(false)
  verifiedAt DateTime?
  attempts   Int       @default(0)
  createdAt  DateTime  @default(now())
  user       User      @relation("UserEmailVerifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([email])
  @@index([expiresAt])
  @@map("email_verifications")
}

model SecurityAuditLog {
  id           String         @id @default(cuid())
  userId       String?
  action       SecurityAction
  resource     String
  resourceId   String?
  ipAddress    String
  userAgent    String?
  deviceId     String?
  fingerprint  String?
  success      Boolean
  errorMessage String?
  errorCode    String?
  riskScore    Int?           @default(0)
  metadata     Json?
  country      String?
  city         String?
  createdAt    DateTime       @default(now())
  user         User?          @relation("UserSecurityLogs", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([ipAddress, createdAt])
  @@index([success])
  @@index([riskScore])
  @@map("security_audit_logs")
}

model CsrfToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String?
  sessionId String?
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([sessionId])
  @@index([expiresAt])
  @@map("csrf_tokens")
}

model PasswordReset {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  used      Boolean   @default(false)
  usedAt    DateTime?
  ipAddress String?
  userAgent String?
  createdAt DateTime  @default(now())

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("password_resets")
}

// NOTE: GradeAssignment model removed - use TeacherSubjectAssignment instead

model TrustedIp {
  id          String    @id @default(cuid())
  userId      String
  ipAddress   String
  description String?
  addedBy     String
  expiresAt   DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())

  @@unique([userId, ipAddress])
  @@index([userId])
  @@index([ipAddress])
  @@map("trusted_ips")
}

model TeacherSubjectAssignment {
  id               String         @id @default(cuid())
  teacherProfileId String
  subjectId        String
  gradeId          String
  mediumId         String
  academicYearId   String
  isActive         Boolean        @default(true)
  canCreateExams   Boolean        @default(true)
  maxStudents      Int?
  effectiveFrom    DateTime       @default(now())
  effectiveTo      DateTime?
  notes            String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  grade            Grade          @relation("GradeAssignments", fields: [gradeId], references: [id], onDelete: Cascade)
  medium           Medium         @relation("MediumAssignments", fields: [mediumId], references: [id], onDelete: Cascade)
  subject          Subject        @relation("SubjectAssignments", fields: [subjectId], references: [id], onDelete: Cascade)
  teacherProfile   TeacherProfile @relation("TeacherSubjectAssignments", fields: [teacherProfileId], references: [id], onDelete: Cascade)
  academicYear     AcademicYear   @relation(fields: [academicYearId], references: [id])
  classes          Class[]        @relation("AssignedClasses")
  timetables       Timetable[]    @relation("TimetableTeacherAssignment")

  @@unique([teacherProfileId, subjectId, gradeId, mediumId, academicYearId])
  @@index([teacherProfileId, isActive])
  @@index([subjectId, gradeId, mediumId])
  @@index([academicYearId])
  @@map("teacher_subject_assignments")
}

model Institution {
  id              String           @id @default(cuid())
  name            String
  code            String?          @unique
  type            String
  address         String?
  phone           String?
  email           String?
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  category        String?
  city            String?
  establishedYear Int?
  postalCode      String?
  principal       String?
  studentCount    Int?
  teacherCount    Int?
  website         String?
  sortOrder       Int?             @default(0)
  zoneId          String?
  zone            Zone?            @relation("InstitutionZone", fields: [zoneId], references: [id])
  teachers        TeacherProfile[] @relation("TeacherInstitution")

  @@index([zoneId])
  @@index([type, isActive])
  @@map("institutions")
}

// ============================================
// JOIN TABLES
// ============================================

model PublicationGrade {
  id            String      @id @default(cuid())
  publicationId String
  gradeId       String
  createdAt     DateTime    @default(now())
  publication   Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  grade         Grade       @relation("PublicationGrades", fields: [gradeId], references: [id], onDelete: Restrict)

  @@unique([publicationId, gradeId])
  @@index([publicationId])
  @@index([gradeId])
  @@map("publication_grades")
}

model PublicationSubject {
  id            String      @id @default(cuid())
  publicationId String
  subjectId     String
  createdAt     DateTime    @default(now())
  publication   Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  subject       Subject     @relation("PublicationSubjects", fields: [subjectId], references: [id], onDelete: Restrict)

  @@unique([publicationId, subjectId])
  @@index([publicationId])
  @@index([subjectId])
  @@map("publication_subjects")
}

model PublicationMedium {
  id            String      @id @default(cuid())
  publicationId String
  mediumId      String
  createdAt     DateTime    @default(now())
  publication   Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)
  medium        Medium      @relation("PublicationMediums", fields: [mediumId], references: [id], onDelete: Restrict)

  @@unique([publicationId, mediumId])
  @@index([publicationId])
  @@index([mediumId])
  @@map("publication_mediums")
}

model CourseMaterialGrade {
  id               String         @id @default(cuid())
  courseMaterialId String
  gradeId          String
  createdAt        DateTime       @default(now())
  courseMaterial   CourseMaterial @relation(fields: [courseMaterialId], references: [id], onDelete: Cascade)
  grade            Grade          @relation("CourseMaterialGrades", fields: [gradeId], references: [id], onDelete: Restrict)

  @@unique([courseMaterialId, gradeId])
  @@index([courseMaterialId])
  @@index([gradeId])
  @@map("course_material_grades")
}

model AnnouncementGrade {
  id             String       @id @default(cuid())
  announcementId String
  gradeId        String
  createdAt      DateTime     @default(now())
  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  grade          Grade        @relation("AnnouncementGrades", fields: [gradeId], references: [id], onDelete: Restrict)

  @@unique([announcementId, gradeId])
  @@index([announcementId])
  @@index([gradeId])
  @@map("announcement_grades")
}

model TransferRequestDesiredZone {
  id                String          @id @default(cuid())
  transferRequestId String
  zoneId            String
  priority          Int             @default(0)
  createdAt         DateTime        @default(now())
  transferRequest   TransferRequest @relation(fields: [transferRequestId], references: [id], onDelete: Cascade)
  zone              Zone            @relation("TransferDesiredZones", fields: [zoneId], references: [id], onDelete: Restrict)

  @@unique([transferRequestId, zoneId])
  @@index([transferRequestId])
  @@index([zoneId])
  @@index([priority])
  @@map("transfer_request_desired_zones")
}

model SystemErrorLog {
  id           String     @id @default(cuid())
  level        ErrorLevel
  message      String
  stackTrace   String?    @db.Text
  route        String?
  method       String?
  statusCode   Int?
  userId       String?
  userAgent    String?
  ipAddress    String?
  requestBody  String?    @db.Text
  responseBody String?    @db.Text
  errorCode    String?
  context      Json?
  resolved     Boolean    @default(false)
  resolvedBy   String?
  resolvedAt   DateTime?
  notes        String?
  occurrences  Int        @default(1)
  firstSeen    DateTime   @default(now())
  lastSeen     DateTime   @default(now())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  user         User?      @relation("ErrorLogUser", fields: [userId], references: [id], onDelete: SetNull)
  resolver     User?      @relation("ErrorLogResolver", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@index([level, resolved, lastSeen])
  @@index([route, method])
  @@index([userId])
  @@index([resolved])
  @@index([lastSeen])
  @@map("system_error_logs")
}

// ============================================
// NEW MODELS FOR ENHANCED FUNCTIONALITY
// ============================================

model Permission {
  id              String           @id @default(cuid())
  key             String           @unique
  name            String
  description     String?
  category        String?
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  rolePermissions RolePermission[]

  @@index([category, isActive])
  @@map("permissions")
}

model RolePermission {
  role         UserRole
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  grantedAt    DateTime   @default(now())

  @@id([role, permissionId])
  @@index([role])
  @@map("role_permissions")
}

model ExamTemplate {
  id          String   @id @default(cuid())
  title       String
  description String?
  structure   Json // Exam structure: parts, sections, question distribution
  duration    Int?
  totalMarks  Float?
  examType    ExamType
  isActive    Boolean  @default(true)
  usageCount  Int      @default(0)
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  creator     User     @relation("ExamTemplateCreator", fields: [createdById], references: [id])

  @@index([examType, isActive])
  @@index([createdById])
  @@map("exam_templates")
}

model SubjectChapter {
  id          String   @id @default(cuid())
  subjectId   String
  gradeId     String?
  name        String
  description String?
  order       Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  subject     Subject  @relation("SubjectChapters", fields: [subjectId], references: [id], onDelete: Cascade)
  grade       Grade?   @relation("ChapterGrade", fields: [gradeId], references: [id])
  topics      Topic[]  @relation("ChapterTopics")

  @@unique([subjectId, name])
  @@index([subjectId, gradeId, order])
  @@index([isActive])
  @@map("subject_chapters")
}

model Topic {
  id                 String         @id @default(cuid())
  chapterId          String
  name               String
  description        String?
  order              Int            @default(0)
  learningObjectives String?        @db.Text
  estimatedDuration  Int? // in minutes
  isActive           Boolean        @default(true)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  chapter            SubjectChapter @relation("ChapterTopics", fields: [chapterId], references: [id], onDelete: Cascade)

  @@unique([chapterId, name])
  @@index([chapterId, order])
  @@index([isActive])
  @@map("topics")
}

model BackgroundJob {
  id           String    @id @default(cuid())
  type         String // notification_delivery, recording_cleanup, ai_monitoring, etc.
  status       JobStatus @default(PENDING)
  priority     Int       @default(0)
  payload      Json?
  result       Json?
  error        String?   @db.Text
  attempts     Int       @default(0)
  maxAttempts  Int       @default(3)
  scheduledFor DateTime?
  startedAt    DateTime?
  completedAt  DateTime?
  failedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([type, status])
  @@index([status, scheduledFor])
  @@index([priority, status])
  @@map("background_jobs")
}

// ============================================
// ENUMS
// ============================================

enum ChatMessageType {
  DIRECT
  GROUP
  ANNOUNCEMENT
}

enum MessageApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AnnouncementType {
  GENERAL
  EXAM
  CLASS
  PAYMENT
  SYSTEM
  EMERGENCY
}

enum AnnouncementPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum MaterialType {
  NOTES
  SLIDES
  VIDEO
  ASSIGNMENT
  REFERENCE
  OTHER
}

enum ProctoringEventType {
  FACE_DETECTED
  FACE_NOT_DETECTED
  MULTIPLE_FACES
  TAB_SWITCH
  WINDOW_BLUR
  COPY_PASTE
  RIGHT_CLICK
  FULL_SCREEN_EXIT
  SUSPICIOUS_ACTIVITY
}

enum SeverityLevel {
  INFO
  WARNING
  CRITICAL
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum SeminarStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
}

enum FeedbackType {
  CLASS
  EXAM
  TEACHER
  PLATFORM
  PUBLICATION
  GENERAL
}

enum FeedbackStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  INTERNAL_TEACHER
  EXTERNAL_TEACHER
  INTERNAL_STUDENT
  EXTERNAL_STUDENT
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING
}

enum ClassStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

enum EnrollmentStatus {
  PENDING
  APPROVED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum ExamType {
  MULTIPLE_CHOICE
  ESSAY
  MIXED
  PRACTICAL
}

enum ExamFormat {
  FULL_ONLINE
  HALF_ONLINE_HALF_UPLOAD
  FULL_UPLOAD
}

enum RankingLevel {
  NATIONAL
  PROVINCIAL
  DISTRICT
  ZONAL
  SCHOOL
}

enum StudentType {
  INTERNAL
  EXTERNAL
  ALL
}

enum ExamStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  PUBLISHED
  ACTIVE
  COMPLETED
  CANCELLED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum QuestionType {
  MULTIPLE_CHOICE
  TRUE_FALSE
  SHORT_ANSWER
  ESSAY
  FILL_BLANK
  MATCHING
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum AttemptStatus {
  STARTED
  IN_PROGRESS
  SUBMITTED
  GRADED
  FLAGGED
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  BANK_TRANSFER
  BANK_SLIP
  DIGITAL_WALLET
  TRACKER_PLUS
  WALLET_CREDITS
}

enum SessionStatus {
  SCHEDULED
  ACTIVE
  ENDED
  CANCELLED
}

enum NotificationType {
  SYSTEM
  CLASS_UPDATE
  EXAM_REMINDER
  PAYMENT_UPDATE
  GRADE_RELEASED
  ANNOUNCEMENT
  CHAT_MESSAGE
  GENERAL
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum ErrorLevel {
  ERROR
  WARNING
  INFO
}

enum AuditAction {
  CREATE
  READ
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  FAILED_LOGIN
  PASSWORD_RESET
  EXAM_START
  EXAM_SUBMIT
  PAYMENT_PROCESS
  MESSAGE_SEND
  MESSAGE_APPROVE
  MESSAGE_REJECT
}

enum PublicationStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum TransferRequestStatus {
  PENDING
  VERIFIED
  PAUSED
  MATCHED
  ACCEPTED
  COMPLETED
  CANCELLED
  REJECTED
}

enum ChangeType {
  CANCEL
  SUBJECT_CHANGE
  TEACHER_CHANGE
  TIME_CHANGE
}

enum AttendanceType {
  CLASS
  EXAM
}

enum TransactionType {
  CREDIT
  DEBIT
  REFUND
}

enum SettingType {
  STRING
  NUMBER
  BOOLEAN
  JSON
  DATE
}

enum TwoFactorMethod {
  TOTP
  SMS
  EMAIL
}

enum SecurityAction {
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGIN_BLOCKED
  LOGOUT
  SESSION_EXPIRED
  TOKEN_REFRESHED
  TOKEN_REVOKED
  TWO_FACTOR_ENABLED
  TWO_FACTOR_DISABLED
  TWO_FACTOR_VERIFIED
  TWO_FACTOR_FAILED
  TWO_FACTOR_BACKUP_USED
  PASSWORD_CHANGE
  PASSWORD_RESET_REQUEST
  PASSWORD_RESET_COMPLETE
  PASSWORD_RESET_FAILED
  EMAIL_VERIFICATION_SENT
  EMAIL_VERIFIED
  EMAIL_VERIFICATION_FAILED
  PHONE_VERIFICATION_SENT
  PHONE_VERIFIED
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED
  ACCOUNT_SUSPENDED
  ACCOUNT_REACTIVATED
  ACCOUNT_DELETED
  SESSION_CREATED
  SESSION_REVOKED
  ALL_SESSIONS_REVOKED
  DEVICE_TRUSTED
  DEVICE_UNTRUSTED
  SUSPICIOUS_LOGIN_DETECTED
  IMPOSSIBLE_TRAVEL_DETECTED
  NEW_DEVICE_LOGIN
  NEW_LOCATION_LOGIN
  MULTIPLE_FAILED_ATTEMPTS
  CSRF_TOKEN_MISMATCH
  PROFILE_UPDATED
  AVATAR_CHANGED
  ROLE_CHANGED
  PERMISSIONS_CHANGED
  API_KEY_CREATED
  API_KEY_REVOKED
  UNAUTHORIZED_ACCESS_ATTEMPT
  RATE_LIMIT_EXCEEDED
}

enum ReconciliationStatus {
  PENDING
  MATCHED
  UNMATCHED
  DISPUTED
  RESOLVED
}

enum ReconciliationType {
  AUTO_MATCHED
  MANUALLY_MATCHED
  UNMATCHED
  SUSPICIOUS
}

enum InvoiceStatus {
  DRAFT
  PENDING
  SENT
  PAID
  OVERDUE
  CANCELLED
  PARTIALLY_PAID
}

enum InvoiceType {
  MONTHLY_FEE
  ENROLLMENT_FEE
  EXAM_FEE
  MATERIAL_FEE
  OTHER
}

enum ExamVisibility {
  INTERNAL_ONLY
  EXTERNAL_ONLY
  BOTH
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  RETRYING
}

model TempSignup {
  id         String    @id @default(cuid())
  phone      String    @unique
  otp        String?
  otpExpires DateTime?
  attempts   Int       @default(0)
  verified   Boolean   @default(false)
  verifiedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@map("temp_signups")
}
